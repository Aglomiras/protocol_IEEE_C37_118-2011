package org.mpei.C37_118_2011_1PMU.parserPacket;

import lombok.extern.slf4j.Slf4j;
import org.mpei.C37_118_2011_1PMU.dataPacket.DtoPacketBleach;
import org.mpei.C37_118_2011_ALL_FRAME.frame.grandFrame.Frame_Ethernet_TCP_IP_IEEE_C37_118_2011;
import org.pcap4j.core.PcapPacket;

import java.nio.ByteBuffer;
import java.time.Instant;
import java.util.Date;
import java.util.Optional;

@Slf4j
public class ParserFrameBleach {
    /**
     * -----------------------------------------------------------------------------------------------------------------
     * Сдвиги в пакетах-------------------------------------------------------------------------------------------------
     * -----------------------------------------------------------------------------------------------------------------
     */
    private final int optionByte = 12;
    private final int configByte = 16;

    /**
     * -----------------------------------------------------------------------------------------------------------------
     * Указатель на байт------------------------------------------------------------------------------------------------
     * -----------------------------------------------------------------------------------------------------------------
     */
    private int countByte = 0;

    /**
     * -----------------------------------------------------------------------------------------------------------------
     * Общий метод по парсингу всех типов кадра протокола IEEE C37.118-2011---------------------------------------------
     * -----------------------------------------------------------------------------------------------------------------
     */
    public Optional<Frame_Ethernet_TCP_IP_IEEE_C37_118_2011> parserData(PcapPacket pcapPacket, DtoPacketBleach dtoPacketBleach) {
        try {
            /**---------------------------------------------------------------------------------------------------------
             * Принятие массива байт------------------------------------------------------------------------------------
             * ---------------------------------------------------------------------------------------------------------
             * */
            byte[] data = pcapPacket.getRawData();

            /**---------------------------------------------------------------------------------------------------------
             * Создаем экземпляр класса - кадра сообщения по C37.118-2011-----------------------------------------------
             * ---------------------------------------------------------------------------------------------------------
             * */
            Frame_Ethernet_TCP_IP_IEEE_C37_118_2011 frameC37 = new Frame_Ethernet_TCP_IP_IEEE_C37_118_2011();

            /**---------------------------------------------------------------------------------------------------------
             * Ethernet II----------------------------------------------------------------------------------------------
             * Присвоение экземпляру кадра, информации о:---------------------------------------------------------------
             * 1. MAC-адресе получателя;--------------------------------------------------------------------------------
             * 2. MAC-адресе источника;---------------------------------------------------------------------------------
             * 3. Типе протокола;---------------------------------------------------------------------------------------
             * ---------------------------------------------------------------------------------------------------------
             * */
            frameC37.setMacDestination(byteArrayToMacAddress(data, countByte));
            countByte = countByte + 6;
            frameC37.setMacSource(byteArrayToMacAddress(data, countByte));
            countByte = countByte + 6;
            frameC37.setType(byteArrayToShort(data, countByte));
            countByte = countByte + 2;

            /**---------------------------------------------------------------------------------------------------------
             * Internet Protocol----------------------------------------------------------------------------------------
             * Присвоение экземпляру кадра следующей информации:--------------------------------------------------------
             * 1. Версия IP;--------------------------------------------------------------------------------------------
             * 2. Длина заголовка;--------------------------------------------------------------------------------------
             * 3. Тип обслуживания, может нести в себе приоритет для определенных приложений;---------------------------
             * 4. Общая длина пакета, заголовок + данные;---------------------------------------------------------------
             * 5. Идентификатор для фрагментации пакета (если пакет разбит на фрагменты, то у всех фрагментов будет один
             * идентификатор);------------------------------------------------------------------------------------------
             * 6. Указатель смещения пакета относительно начала оригинального пакета;-----------------------------------
             * 7. Указатель времени жизни пакета, показывает сколько шагов живет пакет;---------------------------------
             * 8. Указывает протокол на транспортном уровне: TCP - 6, UDP - 17;-----------------------------------------
             * 9. Контрольная сумма заголовка;--------------------------------------------------------------------------
             * 10.IP-адрес получателя;----------------------------------------------------------------------------------
             * 11.IP-адрес источника;-----------------------------------------------------------------------------------
             * ---------------------------------------------------------------------------------------------------------
             * */
            frameC37.setVersion(byteToIntVersion(data, countByte));
            frameC37.setHeaderLength(byteToIntHeader(data, countByte));
            countByte = countByte + 1;
            frameC37.setDifferentiatedServicesField(byteToDiff(data, countByte));
            countByte = countByte + 1;
            frameC37.setLength(byteArrayToLength(data, countByte));
            countByte = countByte + 2;
            frameC37.setIdentification(byteArrayToString(data, countByte));
            countByte = countByte + 2;
            frameC37.setFragmentOffset(byteArrayToString(data, countByte));
            countByte = countByte + 2;
            frameC37.setTimeToLife(byteArrayToInt1(data, countByte));
            countByte = countByte + 1;
            frameC37.setProtocol(byteArrayToInt1(data, countByte));
            countByte = countByte + 1;
            frameC37.setHeaderCheckSum(byteArrayToString(data, countByte));
            countByte = countByte + 2;
            frameC37.setIpDestination(byteArrayToIpAddress(data, countByte));
            countByte = countByte + 4;
            frameC37.setIpSource(byteArrayToIpAddress(data, countByte));
            countByte = countByte + 4;

            /**---------------------------------------------------------------------------------------------------------
             * Transmission Control Protocol----------------------------------------------------------------------------
             * Присвоение экземпляру кадра следующей информации:--------------------------------------------------------
             * 1. Порт получателя;--------------------------------------------------------------------------------------
             * 2. Порт отправителя;-------------------------------------------------------------------------------------
             * 3. Порядковый номер первого байта в этом сегменте;-------------------------------------------------------
             * 4. Порядковый номер следующего байта, который получатель ожидает получить;-------------------------------
             * 5. Длина заголовка TCP;----------------------------------------------------------------------------------
             * 6. Флаг;-------------------------------------------------------------------------------------------------
             * 7. Размер окна;------------------------------------------------------------------------------------------
             * 8. Контрольная сумма;------------------------------------------------------------------------------------
             * 9. Указатель смещения начиная с порядкового номера;------------------------------------------------------
             * ---------------------------------------------------------------------------------------------------------
             * */
            frameC37.setPortDestination(byteArrayToShort(data, countByte));
            countByte = countByte + 2;
            frameC37.setPortSource(byteArrayToShort(data, countByte));
            countByte = countByte + 2;
            frameC37.setSeqNum(byteArrayToInt4(data, countByte));
            countByte = countByte + 4;
            frameC37.setAckNum(byteArrayToInt4(data, countByte));
            countByte = countByte + 4;
            frameC37.setHeaderLengthTCP(byteToIntVersion(data, countByte));
            frameC37.setFlags(byteArrayToString(data, countByte));
            countByte = countByte + 2;
            frameC37.setWindow(byteArrayToShort(data, countByte));
            countByte = countByte + 2;
            frameC37.setCheckSum(byteArrayToString(data, 50));
            countByte = countByte + 2;
            frameC37.setUrgentPointer(byteArrayToShort(data, 52));
            countByte = countByte + 2;

            /**
             * ---------------------------------------------------------------------------------------------------------
             * General packet IEEE C37.118-2011-------------------------------------------------------------------------
             * ---------------------------------------------------------------------------------------------------------
             * */
            /**---------------------------------------------------------------------------------------------------------
             * Идентификатор типа пакета--------------------------------------------------------------------------------
             * ---------------------------------------------------------------------------------------------------------
             * */
            frameC37.getGeneral_frame_ieee_c37_118_2011()
                    .setSynchronizationWord(byteArrayToString(data, countByte + optionByte));
            countByte = countByte + 1;

            /**---------------------------------------------------------------------------------------------------------
             * Добавление информации о количестве станций---------------------------------------------------------------
             * ---------------------------------------------------------------------------------------------------------
             * */
            frameC37.getGeneral_frame_ieee_c37_118_2011().setCounterDataFrame(dtoPacketBleach.getNumStations());

            /**---------------------------------------------------------------------------------------------------------
             * Идентификация типа пакета--------------------------------------------------------------------------------
             * ---------------------------------------------------------------------------------------------------------
             * */
            frameC37.getGeneral_frame_ieee_c37_118_2011()
                    .setRecTypePacket(recognitionTypePacket(data, countByte + optionByte));
            countByte = countByte + 1;

            /**---------------------------------------------------------------------------------------------------------
             * Вызов метода, по созданию нужного объекта под тип кадра (ВЫЗЫВАТЬ СРАЗУ ПОСЛЕ ОПРЕДЕЛЕНИЯ ТИПА КАДРА)----
             * ---------------------------------------------------------------------------------------------------------
             * */
            frameC37.getGeneral_frame_ieee_c37_118_2011().typePacket();

            /**---------------------------------------------------------------------------------------------------------
             * Заполнение служебных полей protocol IEEE C37.118-2011----------------------------------------------------
             * ---------------------------------------------------------------------------------------------------------
             * */
            frameC37.getGeneral_frame_ieee_c37_118_2011()
                    .setFrameSize(byteArrayToShort(data, countByte + optionByte));
            countByte = countByte + 2;
            frameC37.getGeneral_frame_ieee_c37_118_2011()
                    .setPmuDcIdNumber(byteArrayToShort(data, countByte + optionByte));
            countByte = countByte + 2;
            frameC37.getGeneral_frame_ieee_c37_118_2011()
                    .setSOC(byteToSOC(data, countByte + optionByte));
            countByte = countByte + 2;
            frameC37.getGeneral_frame_ieee_c37_118_2011()
                    .setTimeQualityFlag(byteArrayToInt1(data, countByte + optionByte));
            countByte = countByte + 1;
            frameC37.getGeneral_frame_ieee_c37_118_2011()
                    .setFractionOfSecond(byteArrayToInt3(data, countByte + optionByte));

            /**---------------------------------------------------------------------------------------------------------
             * Вытаскиваем идентификатор типа пакета--------------------------------------------------------------------
             * В зависимости от типа пакета, различается его парсинг----------------------------------------------------
             * ---------------------------------------------------------------------------------------------------------
             * */
            int typeC37 = frameC37.getGeneral_frame_ieee_c37_118_2011().getRecTypePacket();

            /**---------------------------------------------------------------------------------------------------------
             * 0 - означает кадр данных (Data Frame)--------------------------------------------------------------------
             * ---------------------------------------------------------------------------------------------------------
             * */
            if (typeC37 == 0) {
                /**-----------------------------------------------------------------------------------------------------
                 * Поочередный парсинг всех блоков данных PMU-----------------------------------------------------------
                 * -----------------------------------------------------------------------------------------------------
                 * */
                for (int i = 0; i < dtoPacketBleach.getNumStations(); i++) {
                    /**-------------------------------------------------------------------------------------------------
                     * Запись значения флага----------------------------------------------------------------------------
                     * -------------------------------------------------------------------------------------------------
                     * */
                    frameC37.getGeneral_frame_ieee_c37_118_2011()
                            .getFrameDataC37().get(i)
                            .setFlag(byteArrayToString(data, 68 + i * 38 + optionByte));

                    for (int j = 0; j < dtoPacketBleach.getNumphasors(); j++) {
                        frameC37.getGeneral_frame_ieee_c37_118_2011()
                                .getFrameDataC37().get(i)
                                .getMeasurements().get(j)
                                .setAmplitude(byteToFloutAmpl(data, 70 + (i * 38) + (j * 8) + optionByte));

                        frameC37.getGeneral_frame_ieee_c37_118_2011()
                                .getFrameDataC37().get(i)
                                .getMeasurements().get(j)
                                .setAngle(byteToFloutAngle(data, 74 + (i * 38) + (j * 8) + optionByte));
                    }

                    /**-------------------------------------------------------------------------------------------------
                     * Запись сдвига по частоте-------------------------------------------------------------------------
                     * -------------------------------------------------------------------------------------------------
                     * */
                    frameC37.getGeneral_frame_ieee_c37_118_2011()
                            .getFrameDataC37().get(0)
                            .setFrequencyDeviation(byteArrayToShort(data, 102 + i * 38 + optionByte));

                    /**-------------------------------------------------------------------------------------------------
                     * Запись скорости изменения частоты----------------------------------------------------------------
                     * -------------------------------------------------------------------------------------------------
                     * */
                    frameC37.getGeneral_frame_ieee_c37_118_2011()
                            .getFrameDataC37().get(0)
                            .setRate(byteArrayToShort(data, 104 + i * 38 + optionByte));

                    /**-------------------------------------------------------------------------------------------------
                     * Запись контрольной суммы-------------------------------------------------------------------------
                     * -------------------------------------------------------------------------------------------------
                     * */
                    frameC37.getGeneral_frame_ieee_c37_118_2011()
                            .setCheckSum(byteArrayToString(data, 106 + i * 38 + optionByte));
                }

                /**-----------------------------------------------------------------------------------------------------
                 * 1 - означает кадр заголовка (Header Frame)-----------------------------------------------------------
                 * -----------------------------------------------------------------------------------------------------
                 * */
            } else if (typeC37 == 1) {
                frameC37.getGeneral_frame_ieee_c37_118_2011().getFrameHeaderC37();

                /**-----------------------------------------------------------------------------------------------------
                 * 3 - означает кадр конфигурации CFG-2 (Configuration Frame)-------------------------------------------
                 * -----------------------------------------------------------------------------------------------------
                 * */
            } else if (typeC37 == 3) {
                /**
                 * CFG-2
                 * */
                /**-----------------------------------------------------------------------------------------------------
                 * Заполнение служебных полей пакета конфигурационного типа---------------------------------------------
                 * -----------------------------------------------------------------------------------------------------
                 * */
                frameC37.getGeneral_frame_ieee_c37_118_2011()
                        .getFrameConfigurationC37().get(0)
                        .setConfig(String.valueOf(byteArrayToInt1(data, 68 + optionByte)));
                frameC37.getGeneral_frame_ieee_c37_118_2011()
                        .getFrameConfigurationC37().get(0)
                        .setResolution(Integer.toBinaryString(byteArrayToInt3(data, 69 + optionByte)));

                short numberPmu = byteArrayToShort(data, 72 + optionByte);
                dtoPacketBleach.setNumStations(numberPmu);

                /**
                 * Записываем количества PMU в пакете
                 * */
                frameC37.getGeneral_frame_ieee_c37_118_2011()
                        .getFrameConfigurationC37().get(0)
                        .setNumberPMU(numberPmu);
                /**
                 * Создаем нужное количество объектов для хранения конфигураций PMU
                 * */
                frameC37.getGeneral_frame_ieee_c37_118_2011()
                        .getFrameConfigurationC37().get(0)
                        .completionDataConfiguration();

                for (int i = 0; i < numberPmu; i++) {
                    frameC37.getGeneral_frame_ieee_c37_118_2011()
                            .getFrameConfigurationC37().get(0)
                            .getDataPmu().get(i)
                            .setPmuDcIdNum(byteArrayToShort(data, 74 + optionByte + configByte + 110 * i));

                    frameC37.getGeneral_frame_ieee_c37_118_2011()
                            .getFrameConfigurationC37().get(0)
                            .getDataPmu().get(i)
                            .setDataFormat(ByteToDataFormat(data, 76 + optionByte + configByte + 110 * i));

                    short numPhasors = byteArrayToShort(data, 78 + optionByte + configByte + 110 * i);
                    dtoPacketBleach.setNumphasors(numPhasors);
                    frameC37.getGeneral_frame_ieee_c37_118_2011()
                            .getFrameConfigurationC37().get(0)
                            .getDataPmu().get(i)
                            .setNumPhasor(numPhasors);

                    short numAnalogs = byteArrayToShort(data, 80 + optionByte + configByte + 110 * i);
                    dtoPacketBleach.setNumAnalogs(numAnalogs);
                    frameC37.getGeneral_frame_ieee_c37_118_2011()
                            .getFrameConfigurationC37().get(0)
                            .getDataPmu().get(i)
                            .setNumAnalog(numAnalogs);

                    short numDigitals = byteArrayToShort(data, 82 + optionByte + configByte + 110 * i);
                    dtoPacketBleach.setNumDigital(numDigitals);
                    frameC37.getGeneral_frame_ieee_c37_118_2011()
                            .getFrameConfigurationC37().get(0)
                            .getDataPmu().get(i)
                            .setNumDigital(numDigitals);

                    frameC37.getGeneral_frame_ieee_c37_118_2011()
                            .getFrameConfigurationC37().get(0)
                            .getDataPmu().get(i)
                            .allAddMeasur();

                    /**
                     * Запись имен фазоров
                     * */
                    for (int j = 0; j < numPhasors; j++) {
                        String nameAmpl = enCode(data, 84 + j * 16 + optionByte + configByte + 110 * i);
                        frameC37.getGeneral_frame_ieee_c37_118_2011()
                                .getFrameConfigurationC37().get(0)
                                .getDataPmu().get(i)
                                .getPhasors().get(j)
                                .setAmplitude(nameAmpl);
                    }

                    /**-------------------------------------------------------------------------------------------------
                     * Запись размерности-------------------------------------------------------------------------------
                     * -------------------------------------------------------------------------------------------------
                     * */
                    for (int j = 0; j < numPhasors; j++) {
                        float angle = byteToFloutAmpl(data, 84 + 64 + j * 4 + optionByte + configByte + 110 * i);
                        frameC37.getGeneral_frame_ieee_c37_118_2011()
                                .getFrameConfigurationC37().get(0)
                                .getDataPmu().get(i)
                                .getPhasors().get(j)
                                .setFactor(angle);
                    }

//                    /**Запись аналоговых каналов*/
//                    for (int j = 0; j < numAnalogs; j++) {
//                        float ampl = byteToFloutAmpl(data, 82 + numPhasors * 16 + j * 16);
//                        frameC37.getGeneral_frame_ieee_c37_118_2011().getFrameConfigurationC37().get(0).getDataPmu().get(i).getAnalogs().get(j).setAmplitude(ampl);
//
//                        float angle = byteToFloutAngle(data, 90 + numPhasors * 16 + j * 16);
//                        frameC37.getGeneral_frame_ieee_c37_118_2011().getFrameConfigurationC37().get(0).getDataPmu().get(i).getAnalogs().get(j).setAngle(angle);
//                    }

                    /**-------------------------------------------------------------------------------------------------
                     * Запись маски (служебная информация)--------------------------------------------------------------
                     * -------------------------------------------------------------------------------------------------
                     * */
                    frameC37.getGeneral_frame_ieee_c37_118_2011()
                            .getFrameConfigurationC37().get(0)
                            .getDataPmu().get(i)
                            .setMasks(byteArrayToBits(new byte[]{
                                    data[84 + 64 + 16 + optionByte + configByte + 110 * i],
                                    data[84 + 64 + 17 + optionByte + configByte + 110 * i]}));

                    /**-------------------------------------------------------------------------------------------------
                     * Запись количества измерений----------------------------------------------------------------------
                     * -------------------------------------------------------------------------------------------------
                     * */
                    frameC37.getGeneral_frame_ieee_c37_118_2011()
                            .getFrameConfigurationC37().get(0)
                            .getDataPmu().get(i)
                            .setConfigChangeCount(byteArrayToShort(data, 84 + 64 + 18 + optionByte + configByte + 110 * i));

                    /**-------------------------------------------------------------------------------------------------
                     * Запись скорости изменения частоты----------------------------------------------------------------
                     * -------------------------------------------------------------------------------------------------
                     * */
                    frameC37.getGeneral_frame_ieee_c37_118_2011()
                            .getFrameConfigurationC37().get(0).
                            getDataPmu().get(i)
                            .setRateOfTransmission(byteArrayToShort(data, 84 + 64 + 20 + optionByte + configByte + 110 * i));
                }

                /**-----------------------------------------------------------------------------------------------------
                 * Запись контрольной суммы-----------------------------------------------------------------------------
                 * -----------------------------------------------------------------------------------------------------
                 * */
                frameC37.getGeneral_frame_ieee_c37_118_2011()
                        .setCheckSum(byteArrayToString(data, 84 + 64 + 22 + optionByte + configByte));


                /**-----------------------------------------------------------------------------------------------------
                 * 2 - означает кадр конфигурации CFG-1 (Configuration Frame)-------------------------------------------
                 * -----------------------------------------------------------------------------------------------------
                 * */
            } else if (typeC37 == 2) {
                /**
                 * CFG-1
                 * */
//                frameC37.getGeneral_frame_ieee_c37_118_2011().getFrameConfigurationC37();


                /**-----------------------------------------------------------------------------------------------------
                 * 4 - означает кадр команды (Command Frame)------------------------------------------------------------
                 * -----------------------------------------------------------------------------------------------------
                 * */
            } else if (typeC37 == 4) {
                frameC37.getGeneral_frame_ieee_c37_118_2011().getFrameCommandC37().get(0).setCommand(byteArrayToShort(data, 68 + optionByte));
                frameC37.getGeneral_frame_ieee_c37_118_2011().setCheckSum(byteArrayToString(data, 70 + optionByte));


                /**-----------------------------------------------------------------------------------------------------
                 * 5 - означает кадр конфигурации CFG-3 (Configuration Frame)-------------------------------------------
                 * -----------------------------------------------------------------------------------------------------
                 * */
            } else if (typeC37 == 5) {
                /**
                 * CFG-3
                 * */
//                frameC37.getGeneral_frame_ieee_c37_118_2011().getFrameConfigurationC37();

            } else {

            }
            countByte = 0;
            return Optional.of(frameC37);
        } catch (Exception exception) {
            exception.printStackTrace();
            log.error("Cannot parse C37.118-2011 packet");
        }
        return Optional.empty();
    }

    /**
     * -----------------------------------------------------------------------------------------------------------------
     * Метод по переводу 6 байт данных в MAC-адрес назначения (формат String)-------------------------------------------
     * -----------------------------------------------------------------------------------------------------------------
     */
    public static String byteArrayToMacAddress(byte[] data, int offset) {
        return String.format("%02X:%02X:%02X:%02X:%02X:%02X",
                data[offset],
                data[1 + offset],
                data[2 + offset],
                data[3 + offset],
                data[4 + offset],
                data[5 + offset]);
    }

    /**
     * -----------------------------------------------------------------------------------------------------------------
     * Метод по переводу 4 байт данных в IP-адрес назначения (формат String)--------------------------------------------
     * -----------------------------------------------------------------------------------------------------------------
     */
    public static String byteArrayToIpAddress(byte[] data, int offset) {
        return String.format("%d.%d.%d.%d.",
                data[offset] & 0xFF,
                data[1 + offset] & 0xFF,
                data[2 + offset] & 0xFF,
                data[3 + offset] & 0xFF);
    }

    /**
     * -----------------------------------------------------------------------------------------------------------------
     * Метод по переводу 2 байт данных в формат short-------------------------------------------------------------------
     * -----------------------------------------------------------------------------------------------------------------
     */
    public static short byteArrayToShort(byte[] data, int offset) {
        return (short) (data[offset + 1] & 0xFF | (data[offset] & 0xFF) << 8);
    }

    /**
     * -----------------------------------------------------------------------------------------------------------------
     * Метод по переводу 1 байта данных в формат int--------------------------------------------------------------------
     * -----------------------------------------------------------------------------------------------------------------
     */
    public static int byteArrayToInt1(byte[] data, int offset) {
        return data[offset] & 0xFF;
    }

    /**
     * -----------------------------------------------------------------------------------------------------------------
     * Метод по переводу 3 байта данных в формат int--------------------------------------------------------------------
     * -----------------------------------------------------------------------------------------------------------------
     */
    public static int byteArrayToInt3(byte[] data, int offset) {
        return data[offset + 2] & 0xFF | (data[offset + 1] & 0xFF) << 8 | (data[offset] & 0xFF) << 16;
    }

    /**
     * -----------------------------------------------------------------------------------------------------------------
     * Метод по переводу 4 байта данных в формат int--------------------------------------------------------------------
     * -----------------------------------------------------------------------------------------------------------------
     */
    public static int byteArrayToInt4(byte[] data, int offset) {
        return data[offset + 3] & 0xFF | (data[offset + 2] & 0xFF) << 8 | (data[offset + 1] & 0xFF) << 16 | (data[offset] & 0xFF) << 24;
    }

    /**
     * -----------------------------------------------------------------------------------------------------------------
     * Метод по переводу 1 байта в формат int, обозначающий версию IP и состоящий из 4 бит данных-----------------------
     * -----------------------------------------------------------------------------------------------------------------
     */
    public static int byteToIntVersion(byte[] data, int offset) {
        return (data[offset] >> 4 & 0xFF);
    }

    /**
     * -----------------------------------------------------------------------------------------------------------------
     * Метод по определению длины заголовка, состоящего из 4 бит данных-------------------------------------------------
     * -----------------------------------------------------------------------------------------------------------------
     */
    public static int byteToIntHeader(byte[] data, int offset) {
        return ((data[offset] & 0b00001111) & 0xFF);
    }

    /***/
    public static String byteToDiff(byte[] data, int offset) {
        return String.format("0x%02x", data[offset]);
    }

    /**
     * -----------------------------------------------------------------------------------------------------------------
     * Метод по определению длины пакета--------------------------------------------------------------------------------
     * -----------------------------------------------------------------------------------------------------------------
     */
    public static int byteArrayToLength(byte[] data, int offset) {
        return (data[offset + 1] & 0xFF | (data[offset] & 0xFF) << 8);
    }

    /***/
    public static String byteArrayToString(byte[] data, int offset) {
        return String.valueOf(((data[offset] & 0xFF) << 8) | (data[1 + offset] & 0xFF));
    }

    /**
     * -----------------------------------------------------------------------------------------------------------------
     * Метод по определению амплитуды (из 4 байт)-----------------------------------------------------------------------
     * -----------------------------------------------------------------------------------------------------------------
     */
    public static float byteToFloutAmpl(byte[] data, int offset) {
        return Float.intBitsToFloat(byteArrayToInt4(data, offset));
    }

    /**
     * -----------------------------------------------------------------------------------------------------------------
     * Метод по определению угла (из 4 байт) в градусах-----------------------------------------------------------------
     * -----------------------------------------------------------------------------------------------------------------
     */
    public static float byteToFloutAngle(byte[] data, int offset) {
        return (float) (Float.intBitsToFloat(byteArrayToInt4(data, offset)) * 180 / Math.PI);
    }

    /**
     * -----------------------------------------------------------------------------------------------------------------
     * Метод по определению амплитуды (из 8 байт)-----------------------------------------------------------------------
     * -----------------------------------------------------------------------------------------------------------------
     */
    public static double byteToDoubleAmpl(byte[] data, int offset) {
        byte[] byteArray = new byte[8];
        for (int i = 0; i < 8; i++) {
            byteArray[i] = data[offset + i];
        }
        return ByteBuffer.wrap(byteArray).getDouble();
    }

    /**
     * -----------------------------------------------------------------------------------------------------------------
     * Метод по определению угла (из 8 байт) в градусах-----------------------------------------------------------------
     * -----------------------------------------------------------------------------------------------------------------
     */
    public static double byteToDoubleAngle(byte[] data, int offset) {
        byte[] byteArray = new byte[8];
        for (int i = 0; i < 8; i++) {
            byteArray[i] = data[offset + i];
        }
        return ByteBuffer.wrap(byteArray).getDouble() * 180 / Math.PI;
    }

    /**
     * -----------------------------------------------------------------------------------------------------------------
     * Метод по определению служебной информации (даты и времени)-------------------------------------------------------
     * -----------------------------------------------------------------------------------------------------------------
     */
    public static Date byteToSOC(byte[] data, int offset) {
        return Date.from(Instant.ofEpochSecond(byteArrayToInt4(data, offset)));
    }

    /**
     * -----------------------------------------------------------------------------------------------------------------
     * Метод по определению идентификатора типа пакета------------------------------------------------------------------
     * -----------------------------------------------------------------------------------------------------------------
     */
    public static int recognitionTypePacket(byte[] data, int offset) {
        return (data[offset] >> 4) & 0xFF;
    }

    /**
     * -----------------------------------------------------------------------------------------------------------------
     * Метод по определению формата данных------------------------------------------------------------------------------
     * -----------------------------------------------------------------------------------------------------------------
     */
    public static String ByteToDataFormat(byte[] data, int offset) {
        byte[] byteArray = new byte[2];
        byteArray[0] = data[offset];
        byteArray[1] = data[offset + 1];
        return byteArrayToBits(byteArray);
    }

    /**
     * -----------------------------------------------------------------------------------------------------------------
     * Метод для представления числа в битах---------------------------------------------------------------------------
     * ----------------------------------------------------------------------------------------------------------------
     */
    public static String byteArrayToBits(byte[] byteArray) {
        StringBuilder bits = new StringBuilder();

        for (byte b : byteArray) {
            String byteToBits = String.format("%8s", Integer.toBinaryString(b & 0xFF)).replace(' ', '0');
            bits.append(byteToBits).append(" ");
        }
        return bits.toString();
    }

    /**
     * -----------------------------------------------------------------------------------------------------------------
     * Метод по переводу байтов в строку--------------------------------------------------------------------------------
     * -----------------------------------------------------------------------------------------------------------------
     */
    public String enCode(byte[] data, int offset) {
        byte[] byteArray = new byte[8];
        for (int i = 0; i < 8; i++) {
            byteArray[i] = data[offset + i];
        }
        return new String(byteArray);
    }
}
